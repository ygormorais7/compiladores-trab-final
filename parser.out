Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID LBRACE decl_list stmt_list RBRACE
Rule 2     decl_list -> decl decl_list
Rule 3     decl_list -> empty
Rule 4     decl -> type ID ASSIGN literal SEMICOLON
Rule 5     decl -> type id_list SEMICOLON
Rule 6     type -> INT
Rule 7     type -> FLOAT
Rule 8     type -> BOOL
Rule 9     type -> STRING
Rule 10    type -> CONST
Rule 11    id_list -> ID id_tail
Rule 12    id_tail -> COLON ID id_tail
Rule 13    id_tail -> empty
Rule 14    stmt_list -> stmt stmt_list
Rule 15    stmt_list -> empty
Rule 16    stmt -> assign_stmt
Rule 17    stmt -> print_stmt
Rule 18    stmt -> input_stmt
Rule 19    stmt -> if_stmt
Rule 20    stmt -> while_stmt
Rule 21    assign_stmt -> ID ASSIGN exp SEMICOLON
Rule 22    print_stmt -> PRINT LPAREN exp_list RPAREN SEMICOLON
Rule 23    input_stmt -> INPUT LPAREN id_list RPAREN SEMICOLON
Rule 24    if_stmt -> IF LPAREN exp RPAREN LBRACE stmt_list RBRACE else_part
Rule 25    else_part -> ELSE LBRACE stmt_list RBRACE
Rule 26    else_part -> empty
Rule 27    while_stmt -> WHILE LPAREN exp RPAREN LBRACE stmt_list RBRACE
Rule 28    exp -> exp_relational
Rule 29    exp_relational -> exp_arithmetic
Rule 30    exp_relational -> exp_arithmetic GT exp_arithmetic
Rule 31    exp_relational -> exp_arithmetic LT exp_arithmetic
Rule 32    exp_relational -> exp_arithmetic GEQ exp_arithmetic
Rule 33    exp_relational -> exp_arithmetic LEQ exp_arithmetic
Rule 34    exp_relational -> exp_arithmetic EQ exp_arithmetic
Rule 35    exp_relational -> exp_arithmetic NEQ exp_arithmetic
Rule 36    exp_arithmetic -> exp_arithmetic PLUS term
Rule 37    exp_arithmetic -> exp_arithmetic MINUS term
Rule 38    exp_arithmetic -> term
Rule 39    term -> term TIMES factor
Rule 40    term -> term DIVIDE factor
Rule 41    term -> factor
Rule 42    term -> unary
Rule 43    unary -> NOT factor
Rule 44    unary -> MINUS factor
Rule 45    BOOL_CONST -> TRUE
Rule 46    BOOL_CONST -> FALSE
Rule 47    factor -> ID
Rule 48    factor -> INTEGER_CONST
Rule 49    factor -> FLOAT_CONST
Rule 50    factor -> STRING_CONST
Rule 51    factor -> BOOL_CONST
Rule 52    factor -> LPAREN exp RPAREN
Rule 53    empty -> <empty>
Rule 54    literal -> INTEGER_CONST
Rule 55    literal -> FLOAT_CONST
Rule 56    literal -> STRING_CONST
Rule 57    literal -> BOOL_CONST
Rule 58    exp_list -> exp exp_tail
Rule 59    exp_tail -> COLON exp exp_tail
Rule 60    exp_tail -> empty

Terminals, with rules where they appear

ASSIGN               : 4 21
BOOL                 : 8
COLON                : 12 59
CONST                : 10
DIVIDE               : 40
ELSE                 : 25
EQ                   : 34
FALSE                : 46
FLOAT                : 7
FLOAT_CONST          : 49 55
GEQ                  : 32
GT                   : 30
ID                   : 1 4 11 12 21 47
IF                   : 24
INPUT                : 23
INT                  : 6
INTEGER_CONST        : 48 54
LBRACE               : 1 24 25 27
LEQ                  : 33
LPAREN               : 22 23 24 27 52
LT                   : 31
MINUS                : 37 44
NEQ                  : 35
NOT                  : 43
PLUS                 : 36
PRINT                : 22
PROGRAM              : 1
RBRACE               : 1 24 25 27
RPAREN               : 22 23 24 27 52
SEMICOLON            : 4 5 21 22 23
STRING               : 9
STRING_CONST         : 50 56
TIMES                : 39
TRUE                 : 45
WHILE                : 27
error                : 

Nonterminals, with rules where they appear

BOOL_CONST           : 51 57
assign_stmt          : 16
decl                 : 2
decl_list            : 1 2
else_part            : 24
empty                : 3 13 15 26 60
exp                  : 21 24 27 52 58 59
exp_arithmetic       : 29 30 30 31 31 32 32 33 33 34 34 35 35 36 37
exp_list             : 22
exp_relational       : 28
exp_tail             : 58 59
factor               : 39 40 41 43 44
id_list              : 5 23
id_tail              : 11 12
if_stmt              : 19
input_stmt           : 18
literal              : 4
print_stmt           : 17
program              : 0
stmt                 : 14
stmt_list            : 1 14 24 25 27
term                 : 36 37 38 39 40
type                 : 4 5
unary                : 42
while_stmt           : 20

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID LBRACE decl_list stmt_list RBRACE

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID LBRACE decl_list stmt_list RBRACE

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . LBRACE decl_list stmt_list RBRACE

    LBRACE          shift and go to state 4


state 4

    (1) program -> PROGRAM ID LBRACE . decl_list stmt_list RBRACE
    (2) decl_list -> . decl decl_list
    (3) decl_list -> . empty
    (4) decl -> . type ID ASSIGN literal SEMICOLON
    (5) decl -> . type id_list SEMICOLON
    (53) empty -> .
    (6) type -> . INT
    (7) type -> . FLOAT
    (8) type -> . BOOL
    (9) type -> . STRING
    (10) type -> . CONST

    ID              reduce using rule 53 (empty -> .)
    PRINT           reduce using rule 53 (empty -> .)
    INPUT           reduce using rule 53 (empty -> .)
    IF              reduce using rule 53 (empty -> .)
    WHILE           reduce using rule 53 (empty -> .)
    RBRACE          reduce using rule 53 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    BOOL            shift and go to state 11
    STRING          shift and go to state 12
    CONST           shift and go to state 13

    decl_list                      shift and go to state 5
    decl                           shift and go to state 6
    empty                          shift and go to state 7
    type                           shift and go to state 8

state 5

    (1) program -> PROGRAM ID LBRACE decl_list . stmt_list RBRACE
    (14) stmt_list -> . stmt stmt_list
    (15) stmt_list -> . empty
    (16) stmt -> . assign_stmt
    (17) stmt -> . print_stmt
    (18) stmt -> . input_stmt
    (19) stmt -> . if_stmt
    (20) stmt -> . while_stmt
    (53) empty -> .
    (21) assign_stmt -> . ID ASSIGN exp SEMICOLON
    (22) print_stmt -> . PRINT LPAREN exp_list RPAREN SEMICOLON
    (23) input_stmt -> . INPUT LPAREN id_list RPAREN SEMICOLON
    (24) if_stmt -> . IF LPAREN exp RPAREN LBRACE stmt_list RBRACE else_part
    (27) while_stmt -> . WHILE LPAREN exp RPAREN LBRACE stmt_list RBRACE

    RBRACE          reduce using rule 53 (empty -> .)
    ID              shift and go to state 14
    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26

    stmt_list                      shift and go to state 15
    stmt                           shift and go to state 16
    empty                          shift and go to state 17
    assign_stmt                    shift and go to state 18
    print_stmt                     shift and go to state 19
    input_stmt                     shift and go to state 20
    if_stmt                        shift and go to state 21
    while_stmt                     shift and go to state 22

state 6

    (2) decl_list -> decl . decl_list
    (2) decl_list -> . decl decl_list
    (3) decl_list -> . empty
    (4) decl -> . type ID ASSIGN literal SEMICOLON
    (5) decl -> . type id_list SEMICOLON
    (53) empty -> .
    (6) type -> . INT
    (7) type -> . FLOAT
    (8) type -> . BOOL
    (9) type -> . STRING
    (10) type -> . CONST

    ID              reduce using rule 53 (empty -> .)
    PRINT           reduce using rule 53 (empty -> .)
    INPUT           reduce using rule 53 (empty -> .)
    IF              reduce using rule 53 (empty -> .)
    WHILE           reduce using rule 53 (empty -> .)
    RBRACE          reduce using rule 53 (empty -> .)
    INT             shift and go to state 9
    FLOAT           shift and go to state 10
    BOOL            shift and go to state 11
    STRING          shift and go to state 12
    CONST           shift and go to state 13

    decl                           shift and go to state 6
    decl_list                      shift and go to state 27
    empty                          shift and go to state 7
    type                           shift and go to state 8

state 7

    (3) decl_list -> empty .

    ID              reduce using rule 3 (decl_list -> empty .)
    PRINT           reduce using rule 3 (decl_list -> empty .)
    INPUT           reduce using rule 3 (decl_list -> empty .)
    IF              reduce using rule 3 (decl_list -> empty .)
    WHILE           reduce using rule 3 (decl_list -> empty .)
    RBRACE          reduce using rule 3 (decl_list -> empty .)


state 8

    (4) decl -> type . ID ASSIGN literal SEMICOLON
    (5) decl -> type . id_list SEMICOLON
    (11) id_list -> . ID id_tail

    ID              shift and go to state 28

    id_list                        shift and go to state 29

state 9

    (6) type -> INT .

    ID              reduce using rule 6 (type -> INT .)


state 10

    (7) type -> FLOAT .

    ID              reduce using rule 7 (type -> FLOAT .)


state 11

    (8) type -> BOOL .

    ID              reduce using rule 8 (type -> BOOL .)


state 12

    (9) type -> STRING .

    ID              reduce using rule 9 (type -> STRING .)


state 13

    (10) type -> CONST .

    ID              reduce using rule 10 (type -> CONST .)


state 14

    (21) assign_stmt -> ID . ASSIGN exp SEMICOLON

    ASSIGN          shift and go to state 30


state 15

    (1) program -> PROGRAM ID LBRACE decl_list stmt_list . RBRACE

    RBRACE          shift and go to state 31


state 16

    (14) stmt_list -> stmt . stmt_list
    (14) stmt_list -> . stmt stmt_list
    (15) stmt_list -> . empty
    (16) stmt -> . assign_stmt
    (17) stmt -> . print_stmt
    (18) stmt -> . input_stmt
    (19) stmt -> . if_stmt
    (20) stmt -> . while_stmt
    (53) empty -> .
    (21) assign_stmt -> . ID ASSIGN exp SEMICOLON
    (22) print_stmt -> . PRINT LPAREN exp_list RPAREN SEMICOLON
    (23) input_stmt -> . INPUT LPAREN id_list RPAREN SEMICOLON
    (24) if_stmt -> . IF LPAREN exp RPAREN LBRACE stmt_list RBRACE else_part
    (27) while_stmt -> . WHILE LPAREN exp RPAREN LBRACE stmt_list RBRACE

    RBRACE          reduce using rule 53 (empty -> .)
    ID              shift and go to state 14
    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26

    stmt                           shift and go to state 16
    stmt_list                      shift and go to state 32
    empty                          shift and go to state 17
    assign_stmt                    shift and go to state 18
    print_stmt                     shift and go to state 19
    input_stmt                     shift and go to state 20
    if_stmt                        shift and go to state 21
    while_stmt                     shift and go to state 22

state 17

    (15) stmt_list -> empty .

    RBRACE          reduce using rule 15 (stmt_list -> empty .)


state 18

    (16) stmt -> assign_stmt .

    ID              reduce using rule 16 (stmt -> assign_stmt .)
    PRINT           reduce using rule 16 (stmt -> assign_stmt .)
    INPUT           reduce using rule 16 (stmt -> assign_stmt .)
    IF              reduce using rule 16 (stmt -> assign_stmt .)
    WHILE           reduce using rule 16 (stmt -> assign_stmt .)
    RBRACE          reduce using rule 16 (stmt -> assign_stmt .)


state 19

    (17) stmt -> print_stmt .

    ID              reduce using rule 17 (stmt -> print_stmt .)
    PRINT           reduce using rule 17 (stmt -> print_stmt .)
    INPUT           reduce using rule 17 (stmt -> print_stmt .)
    IF              reduce using rule 17 (stmt -> print_stmt .)
    WHILE           reduce using rule 17 (stmt -> print_stmt .)
    RBRACE          reduce using rule 17 (stmt -> print_stmt .)


state 20

    (18) stmt -> input_stmt .

    ID              reduce using rule 18 (stmt -> input_stmt .)
    PRINT           reduce using rule 18 (stmt -> input_stmt .)
    INPUT           reduce using rule 18 (stmt -> input_stmt .)
    IF              reduce using rule 18 (stmt -> input_stmt .)
    WHILE           reduce using rule 18 (stmt -> input_stmt .)
    RBRACE          reduce using rule 18 (stmt -> input_stmt .)


state 21

    (19) stmt -> if_stmt .

    ID              reduce using rule 19 (stmt -> if_stmt .)
    PRINT           reduce using rule 19 (stmt -> if_stmt .)
    INPUT           reduce using rule 19 (stmt -> if_stmt .)
    IF              reduce using rule 19 (stmt -> if_stmt .)
    WHILE           reduce using rule 19 (stmt -> if_stmt .)
    RBRACE          reduce using rule 19 (stmt -> if_stmt .)


state 22

    (20) stmt -> while_stmt .

    ID              reduce using rule 20 (stmt -> while_stmt .)
    PRINT           reduce using rule 20 (stmt -> while_stmt .)
    INPUT           reduce using rule 20 (stmt -> while_stmt .)
    IF              reduce using rule 20 (stmt -> while_stmt .)
    WHILE           reduce using rule 20 (stmt -> while_stmt .)
    RBRACE          reduce using rule 20 (stmt -> while_stmt .)


state 23

    (22) print_stmt -> PRINT . LPAREN exp_list RPAREN SEMICOLON

    LPAREN          shift and go to state 33


state 24

    (23) input_stmt -> INPUT . LPAREN id_list RPAREN SEMICOLON

    LPAREN          shift and go to state 34


state 25

    (24) if_stmt -> IF . LPAREN exp RPAREN LBRACE stmt_list RBRACE else_part

    LPAREN          shift and go to state 35


state 26

    (27) while_stmt -> WHILE . LPAREN exp RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 36


state 27

    (2) decl_list -> decl decl_list .

    ID              reduce using rule 2 (decl_list -> decl decl_list .)
    PRINT           reduce using rule 2 (decl_list -> decl decl_list .)
    INPUT           reduce using rule 2 (decl_list -> decl decl_list .)
    IF              reduce using rule 2 (decl_list -> decl decl_list .)
    WHILE           reduce using rule 2 (decl_list -> decl decl_list .)
    RBRACE          reduce using rule 2 (decl_list -> decl decl_list .)


state 28

    (4) decl -> type ID . ASSIGN literal SEMICOLON
    (11) id_list -> ID . id_tail
    (12) id_tail -> . COLON ID id_tail
    (13) id_tail -> . empty
    (53) empty -> .

    ASSIGN          shift and go to state 37
    COLON           shift and go to state 39
    SEMICOLON       reduce using rule 53 (empty -> .)

    id_tail                        shift and go to state 38
    empty                          shift and go to state 40

state 29

    (5) decl -> type id_list . SEMICOLON

    SEMICOLON       shift and go to state 41


state 30

    (21) assign_stmt -> ID ASSIGN . exp SEMICOLON
    (28) exp -> . exp_relational
    (29) exp_relational -> . exp_arithmetic
    (30) exp_relational -> . exp_arithmetic GT exp_arithmetic
    (31) exp_relational -> . exp_arithmetic LT exp_arithmetic
    (32) exp_relational -> . exp_arithmetic GEQ exp_arithmetic
    (33) exp_relational -> . exp_arithmetic LEQ exp_arithmetic
    (34) exp_relational -> . exp_arithmetic EQ exp_arithmetic
    (35) exp_relational -> . exp_arithmetic NEQ exp_arithmetic
    (36) exp_arithmetic -> . exp_arithmetic PLUS term
    (37) exp_arithmetic -> . exp_arithmetic MINUS term
    (38) exp_arithmetic -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . factor
    (42) term -> . unary
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (43) unary -> . NOT factor
    (44) unary -> . MINUS factor
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    NOT             shift and go to state 55
    MINUS           shift and go to state 47
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    exp                            shift and go to state 43
    exp_relational                 shift and go to state 44
    exp_arithmetic                 shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 48
    unary                          shift and go to state 49
    BOOL_CONST                     shift and go to state 53

state 31

    (1) program -> PROGRAM ID LBRACE decl_list stmt_list RBRACE .

    $end            reduce using rule 1 (program -> PROGRAM ID LBRACE decl_list stmt_list RBRACE .)


state 32

    (14) stmt_list -> stmt stmt_list .

    RBRACE          reduce using rule 14 (stmt_list -> stmt stmt_list .)


state 33

    (22) print_stmt -> PRINT LPAREN . exp_list RPAREN SEMICOLON
    (58) exp_list -> . exp exp_tail
    (28) exp -> . exp_relational
    (29) exp_relational -> . exp_arithmetic
    (30) exp_relational -> . exp_arithmetic GT exp_arithmetic
    (31) exp_relational -> . exp_arithmetic LT exp_arithmetic
    (32) exp_relational -> . exp_arithmetic GEQ exp_arithmetic
    (33) exp_relational -> . exp_arithmetic LEQ exp_arithmetic
    (34) exp_relational -> . exp_arithmetic EQ exp_arithmetic
    (35) exp_relational -> . exp_arithmetic NEQ exp_arithmetic
    (36) exp_arithmetic -> . exp_arithmetic PLUS term
    (37) exp_arithmetic -> . exp_arithmetic MINUS term
    (38) exp_arithmetic -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . factor
    (42) term -> . unary
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (43) unary -> . NOT factor
    (44) unary -> . MINUS factor
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    NOT             shift and go to state 55
    MINUS           shift and go to state 47
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    exp_list                       shift and go to state 58
    exp                            shift and go to state 59
    exp_relational                 shift and go to state 44
    exp_arithmetic                 shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 48
    unary                          shift and go to state 49
    BOOL_CONST                     shift and go to state 53

state 34

    (23) input_stmt -> INPUT LPAREN . id_list RPAREN SEMICOLON
    (11) id_list -> . ID id_tail

    ID              shift and go to state 61

    id_list                        shift and go to state 60

state 35

    (24) if_stmt -> IF LPAREN . exp RPAREN LBRACE stmt_list RBRACE else_part
    (28) exp -> . exp_relational
    (29) exp_relational -> . exp_arithmetic
    (30) exp_relational -> . exp_arithmetic GT exp_arithmetic
    (31) exp_relational -> . exp_arithmetic LT exp_arithmetic
    (32) exp_relational -> . exp_arithmetic GEQ exp_arithmetic
    (33) exp_relational -> . exp_arithmetic LEQ exp_arithmetic
    (34) exp_relational -> . exp_arithmetic EQ exp_arithmetic
    (35) exp_relational -> . exp_arithmetic NEQ exp_arithmetic
    (36) exp_arithmetic -> . exp_arithmetic PLUS term
    (37) exp_arithmetic -> . exp_arithmetic MINUS term
    (38) exp_arithmetic -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . factor
    (42) term -> . unary
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (43) unary -> . NOT factor
    (44) unary -> . MINUS factor
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    NOT             shift and go to state 55
    MINUS           shift and go to state 47
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    exp                            shift and go to state 62
    exp_relational                 shift and go to state 44
    exp_arithmetic                 shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 48
    unary                          shift and go to state 49
    BOOL_CONST                     shift and go to state 53

state 36

    (27) while_stmt -> WHILE LPAREN . exp RPAREN LBRACE stmt_list RBRACE
    (28) exp -> . exp_relational
    (29) exp_relational -> . exp_arithmetic
    (30) exp_relational -> . exp_arithmetic GT exp_arithmetic
    (31) exp_relational -> . exp_arithmetic LT exp_arithmetic
    (32) exp_relational -> . exp_arithmetic GEQ exp_arithmetic
    (33) exp_relational -> . exp_arithmetic LEQ exp_arithmetic
    (34) exp_relational -> . exp_arithmetic EQ exp_arithmetic
    (35) exp_relational -> . exp_arithmetic NEQ exp_arithmetic
    (36) exp_arithmetic -> . exp_arithmetic PLUS term
    (37) exp_arithmetic -> . exp_arithmetic MINUS term
    (38) exp_arithmetic -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . factor
    (42) term -> . unary
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (43) unary -> . NOT factor
    (44) unary -> . MINUS factor
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    NOT             shift and go to state 55
    MINUS           shift and go to state 47
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    exp                            shift and go to state 63
    exp_relational                 shift and go to state 44
    exp_arithmetic                 shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 48
    unary                          shift and go to state 49
    BOOL_CONST                     shift and go to state 53

state 37

    (4) decl -> type ID ASSIGN . literal SEMICOLON
    (54) literal -> . INTEGER_CONST
    (55) literal -> . FLOAT_CONST
    (56) literal -> . STRING_CONST
    (57) literal -> . BOOL_CONST
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    INTEGER_CONST   shift and go to state 65
    FLOAT_CONST     shift and go to state 66
    STRING_CONST    shift and go to state 67
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    literal                        shift and go to state 64
    BOOL_CONST                     shift and go to state 68

state 38

    (11) id_list -> ID id_tail .

    SEMICOLON       reduce using rule 11 (id_list -> ID id_tail .)
    RPAREN          reduce using rule 11 (id_list -> ID id_tail .)


state 39

    (12) id_tail -> COLON . ID id_tail

    ID              shift and go to state 69


state 40

    (13) id_tail -> empty .

    SEMICOLON       reduce using rule 13 (id_tail -> empty .)
    RPAREN          reduce using rule 13 (id_tail -> empty .)


state 41

    (5) decl -> type id_list SEMICOLON .

    INT             reduce using rule 5 (decl -> type id_list SEMICOLON .)
    FLOAT           reduce using rule 5 (decl -> type id_list SEMICOLON .)
    BOOL            reduce using rule 5 (decl -> type id_list SEMICOLON .)
    STRING          reduce using rule 5 (decl -> type id_list SEMICOLON .)
    CONST           reduce using rule 5 (decl -> type id_list SEMICOLON .)
    ID              reduce using rule 5 (decl -> type id_list SEMICOLON .)
    PRINT           reduce using rule 5 (decl -> type id_list SEMICOLON .)
    INPUT           reduce using rule 5 (decl -> type id_list SEMICOLON .)
    IF              reduce using rule 5 (decl -> type id_list SEMICOLON .)
    WHILE           reduce using rule 5 (decl -> type id_list SEMICOLON .)
    RBRACE          reduce using rule 5 (decl -> type id_list SEMICOLON .)


state 42

    (47) factor -> ID .

    TIMES           reduce using rule 47 (factor -> ID .)
    DIVIDE          reduce using rule 47 (factor -> ID .)
    GT              reduce using rule 47 (factor -> ID .)
    LT              reduce using rule 47 (factor -> ID .)
    GEQ             reduce using rule 47 (factor -> ID .)
    LEQ             reduce using rule 47 (factor -> ID .)
    EQ              reduce using rule 47 (factor -> ID .)
    NEQ             reduce using rule 47 (factor -> ID .)
    PLUS            reduce using rule 47 (factor -> ID .)
    MINUS           reduce using rule 47 (factor -> ID .)
    SEMICOLON       reduce using rule 47 (factor -> ID .)
    COLON           reduce using rule 47 (factor -> ID .)
    RPAREN          reduce using rule 47 (factor -> ID .)


state 43

    (21) assign_stmt -> ID ASSIGN exp . SEMICOLON

    SEMICOLON       shift and go to state 70


state 44

    (28) exp -> exp_relational .

    SEMICOLON       reduce using rule 28 (exp -> exp_relational .)
    COLON           reduce using rule 28 (exp -> exp_relational .)
    RPAREN          reduce using rule 28 (exp -> exp_relational .)


state 45

    (29) exp_relational -> exp_arithmetic .
    (30) exp_relational -> exp_arithmetic . GT exp_arithmetic
    (31) exp_relational -> exp_arithmetic . LT exp_arithmetic
    (32) exp_relational -> exp_arithmetic . GEQ exp_arithmetic
    (33) exp_relational -> exp_arithmetic . LEQ exp_arithmetic
    (34) exp_relational -> exp_arithmetic . EQ exp_arithmetic
    (35) exp_relational -> exp_arithmetic . NEQ exp_arithmetic
    (36) exp_arithmetic -> exp_arithmetic . PLUS term
    (37) exp_arithmetic -> exp_arithmetic . MINUS term

    SEMICOLON       reduce using rule 29 (exp_relational -> exp_arithmetic .)
    COLON           reduce using rule 29 (exp_relational -> exp_arithmetic .)
    RPAREN          reduce using rule 29 (exp_relational -> exp_arithmetic .)
    GT              shift and go to state 71
    LT              shift and go to state 72
    GEQ             shift and go to state 73
    LEQ             shift and go to state 74
    EQ              shift and go to state 75
    NEQ             shift and go to state 76
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78


state 46

    (38) exp_arithmetic -> term .
    (39) term -> term . TIMES factor
    (40) term -> term . DIVIDE factor

    GT              reduce using rule 38 (exp_arithmetic -> term .)
    LT              reduce using rule 38 (exp_arithmetic -> term .)
    GEQ             reduce using rule 38 (exp_arithmetic -> term .)
    LEQ             reduce using rule 38 (exp_arithmetic -> term .)
    EQ              reduce using rule 38 (exp_arithmetic -> term .)
    NEQ             reduce using rule 38 (exp_arithmetic -> term .)
    PLUS            reduce using rule 38 (exp_arithmetic -> term .)
    MINUS           reduce using rule 38 (exp_arithmetic -> term .)
    SEMICOLON       reduce using rule 38 (exp_arithmetic -> term .)
    COLON           reduce using rule 38 (exp_arithmetic -> term .)
    RPAREN          reduce using rule 38 (exp_arithmetic -> term .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80


state 47

    (44) unary -> MINUS . factor
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    factor                         shift and go to state 81
    BOOL_CONST                     shift and go to state 53

state 48

    (41) term -> factor .

    TIMES           reduce using rule 41 (term -> factor .)
    DIVIDE          reduce using rule 41 (term -> factor .)
    GT              reduce using rule 41 (term -> factor .)
    LT              reduce using rule 41 (term -> factor .)
    GEQ             reduce using rule 41 (term -> factor .)
    LEQ             reduce using rule 41 (term -> factor .)
    EQ              reduce using rule 41 (term -> factor .)
    NEQ             reduce using rule 41 (term -> factor .)
    PLUS            reduce using rule 41 (term -> factor .)
    MINUS           reduce using rule 41 (term -> factor .)
    SEMICOLON       reduce using rule 41 (term -> factor .)
    COLON           reduce using rule 41 (term -> factor .)
    RPAREN          reduce using rule 41 (term -> factor .)


state 49

    (42) term -> unary .

    TIMES           reduce using rule 42 (term -> unary .)
    DIVIDE          reduce using rule 42 (term -> unary .)
    GT              reduce using rule 42 (term -> unary .)
    LT              reduce using rule 42 (term -> unary .)
    GEQ             reduce using rule 42 (term -> unary .)
    LEQ             reduce using rule 42 (term -> unary .)
    EQ              reduce using rule 42 (term -> unary .)
    NEQ             reduce using rule 42 (term -> unary .)
    PLUS            reduce using rule 42 (term -> unary .)
    MINUS           reduce using rule 42 (term -> unary .)
    SEMICOLON       reduce using rule 42 (term -> unary .)
    COLON           reduce using rule 42 (term -> unary .)
    RPAREN          reduce using rule 42 (term -> unary .)


state 50

    (48) factor -> INTEGER_CONST .

    TIMES           reduce using rule 48 (factor -> INTEGER_CONST .)
    DIVIDE          reduce using rule 48 (factor -> INTEGER_CONST .)
    GT              reduce using rule 48 (factor -> INTEGER_CONST .)
    LT              reduce using rule 48 (factor -> INTEGER_CONST .)
    GEQ             reduce using rule 48 (factor -> INTEGER_CONST .)
    LEQ             reduce using rule 48 (factor -> INTEGER_CONST .)
    EQ              reduce using rule 48 (factor -> INTEGER_CONST .)
    NEQ             reduce using rule 48 (factor -> INTEGER_CONST .)
    PLUS            reduce using rule 48 (factor -> INTEGER_CONST .)
    MINUS           reduce using rule 48 (factor -> INTEGER_CONST .)
    SEMICOLON       reduce using rule 48 (factor -> INTEGER_CONST .)
    COLON           reduce using rule 48 (factor -> INTEGER_CONST .)
    RPAREN          reduce using rule 48 (factor -> INTEGER_CONST .)


state 51

    (49) factor -> FLOAT_CONST .

    TIMES           reduce using rule 49 (factor -> FLOAT_CONST .)
    DIVIDE          reduce using rule 49 (factor -> FLOAT_CONST .)
    GT              reduce using rule 49 (factor -> FLOAT_CONST .)
    LT              reduce using rule 49 (factor -> FLOAT_CONST .)
    GEQ             reduce using rule 49 (factor -> FLOAT_CONST .)
    LEQ             reduce using rule 49 (factor -> FLOAT_CONST .)
    EQ              reduce using rule 49 (factor -> FLOAT_CONST .)
    NEQ             reduce using rule 49 (factor -> FLOAT_CONST .)
    PLUS            reduce using rule 49 (factor -> FLOAT_CONST .)
    MINUS           reduce using rule 49 (factor -> FLOAT_CONST .)
    SEMICOLON       reduce using rule 49 (factor -> FLOAT_CONST .)
    COLON           reduce using rule 49 (factor -> FLOAT_CONST .)
    RPAREN          reduce using rule 49 (factor -> FLOAT_CONST .)


state 52

    (50) factor -> STRING_CONST .

    TIMES           reduce using rule 50 (factor -> STRING_CONST .)
    DIVIDE          reduce using rule 50 (factor -> STRING_CONST .)
    GT              reduce using rule 50 (factor -> STRING_CONST .)
    LT              reduce using rule 50 (factor -> STRING_CONST .)
    GEQ             reduce using rule 50 (factor -> STRING_CONST .)
    LEQ             reduce using rule 50 (factor -> STRING_CONST .)
    EQ              reduce using rule 50 (factor -> STRING_CONST .)
    NEQ             reduce using rule 50 (factor -> STRING_CONST .)
    PLUS            reduce using rule 50 (factor -> STRING_CONST .)
    MINUS           reduce using rule 50 (factor -> STRING_CONST .)
    SEMICOLON       reduce using rule 50 (factor -> STRING_CONST .)
    COLON           reduce using rule 50 (factor -> STRING_CONST .)
    RPAREN          reduce using rule 50 (factor -> STRING_CONST .)


state 53

    (51) factor -> BOOL_CONST .

    TIMES           reduce using rule 51 (factor -> BOOL_CONST .)
    DIVIDE          reduce using rule 51 (factor -> BOOL_CONST .)
    GT              reduce using rule 51 (factor -> BOOL_CONST .)
    LT              reduce using rule 51 (factor -> BOOL_CONST .)
    GEQ             reduce using rule 51 (factor -> BOOL_CONST .)
    LEQ             reduce using rule 51 (factor -> BOOL_CONST .)
    EQ              reduce using rule 51 (factor -> BOOL_CONST .)
    NEQ             reduce using rule 51 (factor -> BOOL_CONST .)
    PLUS            reduce using rule 51 (factor -> BOOL_CONST .)
    MINUS           reduce using rule 51 (factor -> BOOL_CONST .)
    SEMICOLON       reduce using rule 51 (factor -> BOOL_CONST .)
    COLON           reduce using rule 51 (factor -> BOOL_CONST .)
    RPAREN          reduce using rule 51 (factor -> BOOL_CONST .)


state 54

    (52) factor -> LPAREN . exp RPAREN
    (28) exp -> . exp_relational
    (29) exp_relational -> . exp_arithmetic
    (30) exp_relational -> . exp_arithmetic GT exp_arithmetic
    (31) exp_relational -> . exp_arithmetic LT exp_arithmetic
    (32) exp_relational -> . exp_arithmetic GEQ exp_arithmetic
    (33) exp_relational -> . exp_arithmetic LEQ exp_arithmetic
    (34) exp_relational -> . exp_arithmetic EQ exp_arithmetic
    (35) exp_relational -> . exp_arithmetic NEQ exp_arithmetic
    (36) exp_arithmetic -> . exp_arithmetic PLUS term
    (37) exp_arithmetic -> . exp_arithmetic MINUS term
    (38) exp_arithmetic -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . factor
    (42) term -> . unary
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (43) unary -> . NOT factor
    (44) unary -> . MINUS factor
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    NOT             shift and go to state 55
    MINUS           shift and go to state 47
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    exp                            shift and go to state 82
    exp_relational                 shift and go to state 44
    exp_arithmetic                 shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 48
    unary                          shift and go to state 49
    BOOL_CONST                     shift and go to state 53

state 55

    (43) unary -> NOT . factor
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    factor                         shift and go to state 83
    BOOL_CONST                     shift and go to state 53

state 56

    (45) BOOL_CONST -> TRUE .

    TIMES           reduce using rule 45 (BOOL_CONST -> TRUE .)
    DIVIDE          reduce using rule 45 (BOOL_CONST -> TRUE .)
    GT              reduce using rule 45 (BOOL_CONST -> TRUE .)
    LT              reduce using rule 45 (BOOL_CONST -> TRUE .)
    GEQ             reduce using rule 45 (BOOL_CONST -> TRUE .)
    LEQ             reduce using rule 45 (BOOL_CONST -> TRUE .)
    EQ              reduce using rule 45 (BOOL_CONST -> TRUE .)
    NEQ             reduce using rule 45 (BOOL_CONST -> TRUE .)
    PLUS            reduce using rule 45 (BOOL_CONST -> TRUE .)
    MINUS           reduce using rule 45 (BOOL_CONST -> TRUE .)
    SEMICOLON       reduce using rule 45 (BOOL_CONST -> TRUE .)
    COLON           reduce using rule 45 (BOOL_CONST -> TRUE .)
    RPAREN          reduce using rule 45 (BOOL_CONST -> TRUE .)


state 57

    (46) BOOL_CONST -> FALSE .

    TIMES           reduce using rule 46 (BOOL_CONST -> FALSE .)
    DIVIDE          reduce using rule 46 (BOOL_CONST -> FALSE .)
    GT              reduce using rule 46 (BOOL_CONST -> FALSE .)
    LT              reduce using rule 46 (BOOL_CONST -> FALSE .)
    GEQ             reduce using rule 46 (BOOL_CONST -> FALSE .)
    LEQ             reduce using rule 46 (BOOL_CONST -> FALSE .)
    EQ              reduce using rule 46 (BOOL_CONST -> FALSE .)
    NEQ             reduce using rule 46 (BOOL_CONST -> FALSE .)
    PLUS            reduce using rule 46 (BOOL_CONST -> FALSE .)
    MINUS           reduce using rule 46 (BOOL_CONST -> FALSE .)
    SEMICOLON       reduce using rule 46 (BOOL_CONST -> FALSE .)
    COLON           reduce using rule 46 (BOOL_CONST -> FALSE .)
    RPAREN          reduce using rule 46 (BOOL_CONST -> FALSE .)


state 58

    (22) print_stmt -> PRINT LPAREN exp_list . RPAREN SEMICOLON

    RPAREN          shift and go to state 84


state 59

    (58) exp_list -> exp . exp_tail
    (59) exp_tail -> . COLON exp exp_tail
    (60) exp_tail -> . empty
    (53) empty -> .

    COLON           shift and go to state 86
    RPAREN          reduce using rule 53 (empty -> .)

    exp_tail                       shift and go to state 85
    empty                          shift and go to state 87

state 60

    (23) input_stmt -> INPUT LPAREN id_list . RPAREN SEMICOLON

    RPAREN          shift and go to state 88


state 61

    (11) id_list -> ID . id_tail
    (12) id_tail -> . COLON ID id_tail
    (13) id_tail -> . empty
    (53) empty -> .

    COLON           shift and go to state 39
    RPAREN          reduce using rule 53 (empty -> .)

    id_tail                        shift and go to state 38
    empty                          shift and go to state 40

state 62

    (24) if_stmt -> IF LPAREN exp . RPAREN LBRACE stmt_list RBRACE else_part

    RPAREN          shift and go to state 89


state 63

    (27) while_stmt -> WHILE LPAREN exp . RPAREN LBRACE stmt_list RBRACE

    RPAREN          shift and go to state 90


state 64

    (4) decl -> type ID ASSIGN literal . SEMICOLON

    SEMICOLON       shift and go to state 91


state 65

    (54) literal -> INTEGER_CONST .

    SEMICOLON       reduce using rule 54 (literal -> INTEGER_CONST .)


state 66

    (55) literal -> FLOAT_CONST .

    SEMICOLON       reduce using rule 55 (literal -> FLOAT_CONST .)


state 67

    (56) literal -> STRING_CONST .

    SEMICOLON       reduce using rule 56 (literal -> STRING_CONST .)


state 68

    (57) literal -> BOOL_CONST .

    SEMICOLON       reduce using rule 57 (literal -> BOOL_CONST .)


state 69

    (12) id_tail -> COLON ID . id_tail
    (12) id_tail -> . COLON ID id_tail
    (13) id_tail -> . empty
    (53) empty -> .

    COLON           shift and go to state 39
    SEMICOLON       reduce using rule 53 (empty -> .)
    RPAREN          reduce using rule 53 (empty -> .)

    id_tail                        shift and go to state 92
    empty                          shift and go to state 40

state 70

    (21) assign_stmt -> ID ASSIGN exp SEMICOLON .

    ID              reduce using rule 21 (assign_stmt -> ID ASSIGN exp SEMICOLON .)
    PRINT           reduce using rule 21 (assign_stmt -> ID ASSIGN exp SEMICOLON .)
    INPUT           reduce using rule 21 (assign_stmt -> ID ASSIGN exp SEMICOLON .)
    IF              reduce using rule 21 (assign_stmt -> ID ASSIGN exp SEMICOLON .)
    WHILE           reduce using rule 21 (assign_stmt -> ID ASSIGN exp SEMICOLON .)
    RBRACE          reduce using rule 21 (assign_stmt -> ID ASSIGN exp SEMICOLON .)


state 71

    (30) exp_relational -> exp_arithmetic GT . exp_arithmetic
    (36) exp_arithmetic -> . exp_arithmetic PLUS term
    (37) exp_arithmetic -> . exp_arithmetic MINUS term
    (38) exp_arithmetic -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . factor
    (42) term -> . unary
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (43) unary -> . NOT factor
    (44) unary -> . MINUS factor
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    NOT             shift and go to state 55
    MINUS           shift and go to state 47
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    exp_arithmetic                 shift and go to state 93
    term                           shift and go to state 46
    factor                         shift and go to state 48
    unary                          shift and go to state 49
    BOOL_CONST                     shift and go to state 53

state 72

    (31) exp_relational -> exp_arithmetic LT . exp_arithmetic
    (36) exp_arithmetic -> . exp_arithmetic PLUS term
    (37) exp_arithmetic -> . exp_arithmetic MINUS term
    (38) exp_arithmetic -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . factor
    (42) term -> . unary
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (43) unary -> . NOT factor
    (44) unary -> . MINUS factor
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    NOT             shift and go to state 55
    MINUS           shift and go to state 47
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    exp_arithmetic                 shift and go to state 94
    term                           shift and go to state 46
    factor                         shift and go to state 48
    unary                          shift and go to state 49
    BOOL_CONST                     shift and go to state 53

state 73

    (32) exp_relational -> exp_arithmetic GEQ . exp_arithmetic
    (36) exp_arithmetic -> . exp_arithmetic PLUS term
    (37) exp_arithmetic -> . exp_arithmetic MINUS term
    (38) exp_arithmetic -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . factor
    (42) term -> . unary
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (43) unary -> . NOT factor
    (44) unary -> . MINUS factor
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    NOT             shift and go to state 55
    MINUS           shift and go to state 47
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    exp_arithmetic                 shift and go to state 95
    term                           shift and go to state 46
    factor                         shift and go to state 48
    unary                          shift and go to state 49
    BOOL_CONST                     shift and go to state 53

state 74

    (33) exp_relational -> exp_arithmetic LEQ . exp_arithmetic
    (36) exp_arithmetic -> . exp_arithmetic PLUS term
    (37) exp_arithmetic -> . exp_arithmetic MINUS term
    (38) exp_arithmetic -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . factor
    (42) term -> . unary
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (43) unary -> . NOT factor
    (44) unary -> . MINUS factor
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    NOT             shift and go to state 55
    MINUS           shift and go to state 47
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    exp_arithmetic                 shift and go to state 96
    term                           shift and go to state 46
    factor                         shift and go to state 48
    unary                          shift and go to state 49
    BOOL_CONST                     shift and go to state 53

state 75

    (34) exp_relational -> exp_arithmetic EQ . exp_arithmetic
    (36) exp_arithmetic -> . exp_arithmetic PLUS term
    (37) exp_arithmetic -> . exp_arithmetic MINUS term
    (38) exp_arithmetic -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . factor
    (42) term -> . unary
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (43) unary -> . NOT factor
    (44) unary -> . MINUS factor
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    NOT             shift and go to state 55
    MINUS           shift and go to state 47
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    exp_arithmetic                 shift and go to state 97
    term                           shift and go to state 46
    factor                         shift and go to state 48
    unary                          shift and go to state 49
    BOOL_CONST                     shift and go to state 53

state 76

    (35) exp_relational -> exp_arithmetic NEQ . exp_arithmetic
    (36) exp_arithmetic -> . exp_arithmetic PLUS term
    (37) exp_arithmetic -> . exp_arithmetic MINUS term
    (38) exp_arithmetic -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . factor
    (42) term -> . unary
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (43) unary -> . NOT factor
    (44) unary -> . MINUS factor
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    NOT             shift and go to state 55
    MINUS           shift and go to state 47
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    exp_arithmetic                 shift and go to state 98
    term                           shift and go to state 46
    factor                         shift and go to state 48
    unary                          shift and go to state 49
    BOOL_CONST                     shift and go to state 53

state 77

    (36) exp_arithmetic -> exp_arithmetic PLUS . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . factor
    (42) term -> . unary
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (43) unary -> . NOT factor
    (44) unary -> . MINUS factor
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    NOT             shift and go to state 55
    MINUS           shift and go to state 47
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    term                           shift and go to state 99
    factor                         shift and go to state 48
    unary                          shift and go to state 49
    BOOL_CONST                     shift and go to state 53

state 78

    (37) exp_arithmetic -> exp_arithmetic MINUS . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . factor
    (42) term -> . unary
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (43) unary -> . NOT factor
    (44) unary -> . MINUS factor
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    NOT             shift and go to state 55
    MINUS           shift and go to state 47
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    term                           shift and go to state 100
    factor                         shift and go to state 48
    unary                          shift and go to state 49
    BOOL_CONST                     shift and go to state 53

state 79

    (39) term -> term TIMES . factor
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    factor                         shift and go to state 101
    BOOL_CONST                     shift and go to state 53

state 80

    (40) term -> term DIVIDE . factor
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    factor                         shift and go to state 102
    BOOL_CONST                     shift and go to state 53

state 81

    (44) unary -> MINUS factor .

    TIMES           reduce using rule 44 (unary -> MINUS factor .)
    DIVIDE          reduce using rule 44 (unary -> MINUS factor .)
    GT              reduce using rule 44 (unary -> MINUS factor .)
    LT              reduce using rule 44 (unary -> MINUS factor .)
    GEQ             reduce using rule 44 (unary -> MINUS factor .)
    LEQ             reduce using rule 44 (unary -> MINUS factor .)
    EQ              reduce using rule 44 (unary -> MINUS factor .)
    NEQ             reduce using rule 44 (unary -> MINUS factor .)
    PLUS            reduce using rule 44 (unary -> MINUS factor .)
    MINUS           reduce using rule 44 (unary -> MINUS factor .)
    SEMICOLON       reduce using rule 44 (unary -> MINUS factor .)
    COLON           reduce using rule 44 (unary -> MINUS factor .)
    RPAREN          reduce using rule 44 (unary -> MINUS factor .)


state 82

    (52) factor -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 103


state 83

    (43) unary -> NOT factor .

    TIMES           reduce using rule 43 (unary -> NOT factor .)
    DIVIDE          reduce using rule 43 (unary -> NOT factor .)
    GT              reduce using rule 43 (unary -> NOT factor .)
    LT              reduce using rule 43 (unary -> NOT factor .)
    GEQ             reduce using rule 43 (unary -> NOT factor .)
    LEQ             reduce using rule 43 (unary -> NOT factor .)
    EQ              reduce using rule 43 (unary -> NOT factor .)
    NEQ             reduce using rule 43 (unary -> NOT factor .)
    PLUS            reduce using rule 43 (unary -> NOT factor .)
    MINUS           reduce using rule 43 (unary -> NOT factor .)
    SEMICOLON       reduce using rule 43 (unary -> NOT factor .)
    COLON           reduce using rule 43 (unary -> NOT factor .)
    RPAREN          reduce using rule 43 (unary -> NOT factor .)


state 84

    (22) print_stmt -> PRINT LPAREN exp_list RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 104


state 85

    (58) exp_list -> exp exp_tail .

    RPAREN          reduce using rule 58 (exp_list -> exp exp_tail .)


state 86

    (59) exp_tail -> COLON . exp exp_tail
    (28) exp -> . exp_relational
    (29) exp_relational -> . exp_arithmetic
    (30) exp_relational -> . exp_arithmetic GT exp_arithmetic
    (31) exp_relational -> . exp_arithmetic LT exp_arithmetic
    (32) exp_relational -> . exp_arithmetic GEQ exp_arithmetic
    (33) exp_relational -> . exp_arithmetic LEQ exp_arithmetic
    (34) exp_relational -> . exp_arithmetic EQ exp_arithmetic
    (35) exp_relational -> . exp_arithmetic NEQ exp_arithmetic
    (36) exp_arithmetic -> . exp_arithmetic PLUS term
    (37) exp_arithmetic -> . exp_arithmetic MINUS term
    (38) exp_arithmetic -> . term
    (39) term -> . term TIMES factor
    (40) term -> . term DIVIDE factor
    (41) term -> . factor
    (42) term -> . unary
    (47) factor -> . ID
    (48) factor -> . INTEGER_CONST
    (49) factor -> . FLOAT_CONST
    (50) factor -> . STRING_CONST
    (51) factor -> . BOOL_CONST
    (52) factor -> . LPAREN exp RPAREN
    (43) unary -> . NOT factor
    (44) unary -> . MINUS factor
    (45) BOOL_CONST -> . TRUE
    (46) BOOL_CONST -> . FALSE

    ID              shift and go to state 42
    INTEGER_CONST   shift and go to state 50
    FLOAT_CONST     shift and go to state 51
    STRING_CONST    shift and go to state 52
    LPAREN          shift and go to state 54
    NOT             shift and go to state 55
    MINUS           shift and go to state 47
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57

    exp                            shift and go to state 105
    exp_relational                 shift and go to state 44
    exp_arithmetic                 shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 48
    unary                          shift and go to state 49
    BOOL_CONST                     shift and go to state 53

state 87

    (60) exp_tail -> empty .

    RPAREN          reduce using rule 60 (exp_tail -> empty .)


state 88

    (23) input_stmt -> INPUT LPAREN id_list RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 106


state 89

    (24) if_stmt -> IF LPAREN exp RPAREN . LBRACE stmt_list RBRACE else_part

    LBRACE          shift and go to state 107


state 90

    (27) while_stmt -> WHILE LPAREN exp RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 108


state 91

    (4) decl -> type ID ASSIGN literal SEMICOLON .

    INT             reduce using rule 4 (decl -> type ID ASSIGN literal SEMICOLON .)
    FLOAT           reduce using rule 4 (decl -> type ID ASSIGN literal SEMICOLON .)
    BOOL            reduce using rule 4 (decl -> type ID ASSIGN literal SEMICOLON .)
    STRING          reduce using rule 4 (decl -> type ID ASSIGN literal SEMICOLON .)
    CONST           reduce using rule 4 (decl -> type ID ASSIGN literal SEMICOLON .)
    ID              reduce using rule 4 (decl -> type ID ASSIGN literal SEMICOLON .)
    PRINT           reduce using rule 4 (decl -> type ID ASSIGN literal SEMICOLON .)
    INPUT           reduce using rule 4 (decl -> type ID ASSIGN literal SEMICOLON .)
    IF              reduce using rule 4 (decl -> type ID ASSIGN literal SEMICOLON .)
    WHILE           reduce using rule 4 (decl -> type ID ASSIGN literal SEMICOLON .)
    RBRACE          reduce using rule 4 (decl -> type ID ASSIGN literal SEMICOLON .)


state 92

    (12) id_tail -> COLON ID id_tail .

    SEMICOLON       reduce using rule 12 (id_tail -> COLON ID id_tail .)
    RPAREN          reduce using rule 12 (id_tail -> COLON ID id_tail .)


state 93

    (30) exp_relational -> exp_arithmetic GT exp_arithmetic .
    (36) exp_arithmetic -> exp_arithmetic . PLUS term
    (37) exp_arithmetic -> exp_arithmetic . MINUS term

    SEMICOLON       reduce using rule 30 (exp_relational -> exp_arithmetic GT exp_arithmetic .)
    COLON           reduce using rule 30 (exp_relational -> exp_arithmetic GT exp_arithmetic .)
    RPAREN          reduce using rule 30 (exp_relational -> exp_arithmetic GT exp_arithmetic .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78


state 94

    (31) exp_relational -> exp_arithmetic LT exp_arithmetic .
    (36) exp_arithmetic -> exp_arithmetic . PLUS term
    (37) exp_arithmetic -> exp_arithmetic . MINUS term

    SEMICOLON       reduce using rule 31 (exp_relational -> exp_arithmetic LT exp_arithmetic .)
    COLON           reduce using rule 31 (exp_relational -> exp_arithmetic LT exp_arithmetic .)
    RPAREN          reduce using rule 31 (exp_relational -> exp_arithmetic LT exp_arithmetic .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78


state 95

    (32) exp_relational -> exp_arithmetic GEQ exp_arithmetic .
    (36) exp_arithmetic -> exp_arithmetic . PLUS term
    (37) exp_arithmetic -> exp_arithmetic . MINUS term

    SEMICOLON       reduce using rule 32 (exp_relational -> exp_arithmetic GEQ exp_arithmetic .)
    COLON           reduce using rule 32 (exp_relational -> exp_arithmetic GEQ exp_arithmetic .)
    RPAREN          reduce using rule 32 (exp_relational -> exp_arithmetic GEQ exp_arithmetic .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78


state 96

    (33) exp_relational -> exp_arithmetic LEQ exp_arithmetic .
    (36) exp_arithmetic -> exp_arithmetic . PLUS term
    (37) exp_arithmetic -> exp_arithmetic . MINUS term

    SEMICOLON       reduce using rule 33 (exp_relational -> exp_arithmetic LEQ exp_arithmetic .)
    COLON           reduce using rule 33 (exp_relational -> exp_arithmetic LEQ exp_arithmetic .)
    RPAREN          reduce using rule 33 (exp_relational -> exp_arithmetic LEQ exp_arithmetic .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78


state 97

    (34) exp_relational -> exp_arithmetic EQ exp_arithmetic .
    (36) exp_arithmetic -> exp_arithmetic . PLUS term
    (37) exp_arithmetic -> exp_arithmetic . MINUS term

    SEMICOLON       reduce using rule 34 (exp_relational -> exp_arithmetic EQ exp_arithmetic .)
    COLON           reduce using rule 34 (exp_relational -> exp_arithmetic EQ exp_arithmetic .)
    RPAREN          reduce using rule 34 (exp_relational -> exp_arithmetic EQ exp_arithmetic .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78


state 98

    (35) exp_relational -> exp_arithmetic NEQ exp_arithmetic .
    (36) exp_arithmetic -> exp_arithmetic . PLUS term
    (37) exp_arithmetic -> exp_arithmetic . MINUS term

    SEMICOLON       reduce using rule 35 (exp_relational -> exp_arithmetic NEQ exp_arithmetic .)
    COLON           reduce using rule 35 (exp_relational -> exp_arithmetic NEQ exp_arithmetic .)
    RPAREN          reduce using rule 35 (exp_relational -> exp_arithmetic NEQ exp_arithmetic .)
    PLUS            shift and go to state 77
    MINUS           shift and go to state 78


state 99

    (36) exp_arithmetic -> exp_arithmetic PLUS term .
    (39) term -> term . TIMES factor
    (40) term -> term . DIVIDE factor

    GT              reduce using rule 36 (exp_arithmetic -> exp_arithmetic PLUS term .)
    LT              reduce using rule 36 (exp_arithmetic -> exp_arithmetic PLUS term .)
    GEQ             reduce using rule 36 (exp_arithmetic -> exp_arithmetic PLUS term .)
    LEQ             reduce using rule 36 (exp_arithmetic -> exp_arithmetic PLUS term .)
    EQ              reduce using rule 36 (exp_arithmetic -> exp_arithmetic PLUS term .)
    NEQ             reduce using rule 36 (exp_arithmetic -> exp_arithmetic PLUS term .)
    PLUS            reduce using rule 36 (exp_arithmetic -> exp_arithmetic PLUS term .)
    MINUS           reduce using rule 36 (exp_arithmetic -> exp_arithmetic PLUS term .)
    SEMICOLON       reduce using rule 36 (exp_arithmetic -> exp_arithmetic PLUS term .)
    COLON           reduce using rule 36 (exp_arithmetic -> exp_arithmetic PLUS term .)
    RPAREN          reduce using rule 36 (exp_arithmetic -> exp_arithmetic PLUS term .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80


state 100

    (37) exp_arithmetic -> exp_arithmetic MINUS term .
    (39) term -> term . TIMES factor
    (40) term -> term . DIVIDE factor

    GT              reduce using rule 37 (exp_arithmetic -> exp_arithmetic MINUS term .)
    LT              reduce using rule 37 (exp_arithmetic -> exp_arithmetic MINUS term .)
    GEQ             reduce using rule 37 (exp_arithmetic -> exp_arithmetic MINUS term .)
    LEQ             reduce using rule 37 (exp_arithmetic -> exp_arithmetic MINUS term .)
    EQ              reduce using rule 37 (exp_arithmetic -> exp_arithmetic MINUS term .)
    NEQ             reduce using rule 37 (exp_arithmetic -> exp_arithmetic MINUS term .)
    PLUS            reduce using rule 37 (exp_arithmetic -> exp_arithmetic MINUS term .)
    MINUS           reduce using rule 37 (exp_arithmetic -> exp_arithmetic MINUS term .)
    SEMICOLON       reduce using rule 37 (exp_arithmetic -> exp_arithmetic MINUS term .)
    COLON           reduce using rule 37 (exp_arithmetic -> exp_arithmetic MINUS term .)
    RPAREN          reduce using rule 37 (exp_arithmetic -> exp_arithmetic MINUS term .)
    TIMES           shift and go to state 79
    DIVIDE          shift and go to state 80


state 101

    (39) term -> term TIMES factor .

    TIMES           reduce using rule 39 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 39 (term -> term TIMES factor .)
    GT              reduce using rule 39 (term -> term TIMES factor .)
    LT              reduce using rule 39 (term -> term TIMES factor .)
    GEQ             reduce using rule 39 (term -> term TIMES factor .)
    LEQ             reduce using rule 39 (term -> term TIMES factor .)
    EQ              reduce using rule 39 (term -> term TIMES factor .)
    NEQ             reduce using rule 39 (term -> term TIMES factor .)
    PLUS            reduce using rule 39 (term -> term TIMES factor .)
    MINUS           reduce using rule 39 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 39 (term -> term TIMES factor .)
    COLON           reduce using rule 39 (term -> term TIMES factor .)
    RPAREN          reduce using rule 39 (term -> term TIMES factor .)


state 102

    (40) term -> term DIVIDE factor .

    TIMES           reduce using rule 40 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 40 (term -> term DIVIDE factor .)
    GT              reduce using rule 40 (term -> term DIVIDE factor .)
    LT              reduce using rule 40 (term -> term DIVIDE factor .)
    GEQ             reduce using rule 40 (term -> term DIVIDE factor .)
    LEQ             reduce using rule 40 (term -> term DIVIDE factor .)
    EQ              reduce using rule 40 (term -> term DIVIDE factor .)
    NEQ             reduce using rule 40 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 40 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 40 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 40 (term -> term DIVIDE factor .)
    COLON           reduce using rule 40 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 40 (term -> term DIVIDE factor .)


state 103

    (52) factor -> LPAREN exp RPAREN .

    TIMES           reduce using rule 52 (factor -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 52 (factor -> LPAREN exp RPAREN .)
    GT              reduce using rule 52 (factor -> LPAREN exp RPAREN .)
    LT              reduce using rule 52 (factor -> LPAREN exp RPAREN .)
    GEQ             reduce using rule 52 (factor -> LPAREN exp RPAREN .)
    LEQ             reduce using rule 52 (factor -> LPAREN exp RPAREN .)
    EQ              reduce using rule 52 (factor -> LPAREN exp RPAREN .)
    NEQ             reduce using rule 52 (factor -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 52 (factor -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 52 (factor -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 52 (factor -> LPAREN exp RPAREN .)
    COLON           reduce using rule 52 (factor -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 52 (factor -> LPAREN exp RPAREN .)


state 104

    (22) print_stmt -> PRINT LPAREN exp_list RPAREN SEMICOLON .

    ID              reduce using rule 22 (print_stmt -> PRINT LPAREN exp_list RPAREN SEMICOLON .)
    PRINT           reduce using rule 22 (print_stmt -> PRINT LPAREN exp_list RPAREN SEMICOLON .)
    INPUT           reduce using rule 22 (print_stmt -> PRINT LPAREN exp_list RPAREN SEMICOLON .)
    IF              reduce using rule 22 (print_stmt -> PRINT LPAREN exp_list RPAREN SEMICOLON .)
    WHILE           reduce using rule 22 (print_stmt -> PRINT LPAREN exp_list RPAREN SEMICOLON .)
    RBRACE          reduce using rule 22 (print_stmt -> PRINT LPAREN exp_list RPAREN SEMICOLON .)


state 105

    (59) exp_tail -> COLON exp . exp_tail
    (59) exp_tail -> . COLON exp exp_tail
    (60) exp_tail -> . empty
    (53) empty -> .

    COLON           shift and go to state 86
    RPAREN          reduce using rule 53 (empty -> .)

    exp_tail                       shift and go to state 109
    empty                          shift and go to state 87

state 106

    (23) input_stmt -> INPUT LPAREN id_list RPAREN SEMICOLON .

    ID              reduce using rule 23 (input_stmt -> INPUT LPAREN id_list RPAREN SEMICOLON .)
    PRINT           reduce using rule 23 (input_stmt -> INPUT LPAREN id_list RPAREN SEMICOLON .)
    INPUT           reduce using rule 23 (input_stmt -> INPUT LPAREN id_list RPAREN SEMICOLON .)
    IF              reduce using rule 23 (input_stmt -> INPUT LPAREN id_list RPAREN SEMICOLON .)
    WHILE           reduce using rule 23 (input_stmt -> INPUT LPAREN id_list RPAREN SEMICOLON .)
    RBRACE          reduce using rule 23 (input_stmt -> INPUT LPAREN id_list RPAREN SEMICOLON .)


state 107

    (24) if_stmt -> IF LPAREN exp RPAREN LBRACE . stmt_list RBRACE else_part
    (14) stmt_list -> . stmt stmt_list
    (15) stmt_list -> . empty
    (16) stmt -> . assign_stmt
    (17) stmt -> . print_stmt
    (18) stmt -> . input_stmt
    (19) stmt -> . if_stmt
    (20) stmt -> . while_stmt
    (53) empty -> .
    (21) assign_stmt -> . ID ASSIGN exp SEMICOLON
    (22) print_stmt -> . PRINT LPAREN exp_list RPAREN SEMICOLON
    (23) input_stmt -> . INPUT LPAREN id_list RPAREN SEMICOLON
    (24) if_stmt -> . IF LPAREN exp RPAREN LBRACE stmt_list RBRACE else_part
    (27) while_stmt -> . WHILE LPAREN exp RPAREN LBRACE stmt_list RBRACE

    RBRACE          reduce using rule 53 (empty -> .)
    ID              shift and go to state 14
    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26

    stmt_list                      shift and go to state 110
    stmt                           shift and go to state 16
    empty                          shift and go to state 17
    assign_stmt                    shift and go to state 18
    print_stmt                     shift and go to state 19
    input_stmt                     shift and go to state 20
    if_stmt                        shift and go to state 21
    while_stmt                     shift and go to state 22

state 108

    (27) while_stmt -> WHILE LPAREN exp RPAREN LBRACE . stmt_list RBRACE
    (14) stmt_list -> . stmt stmt_list
    (15) stmt_list -> . empty
    (16) stmt -> . assign_stmt
    (17) stmt -> . print_stmt
    (18) stmt -> . input_stmt
    (19) stmt -> . if_stmt
    (20) stmt -> . while_stmt
    (53) empty -> .
    (21) assign_stmt -> . ID ASSIGN exp SEMICOLON
    (22) print_stmt -> . PRINT LPAREN exp_list RPAREN SEMICOLON
    (23) input_stmt -> . INPUT LPAREN id_list RPAREN SEMICOLON
    (24) if_stmt -> . IF LPAREN exp RPAREN LBRACE stmt_list RBRACE else_part
    (27) while_stmt -> . WHILE LPAREN exp RPAREN LBRACE stmt_list RBRACE

    RBRACE          reduce using rule 53 (empty -> .)
    ID              shift and go to state 14
    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26

    stmt_list                      shift and go to state 111
    stmt                           shift and go to state 16
    empty                          shift and go to state 17
    assign_stmt                    shift and go to state 18
    print_stmt                     shift and go to state 19
    input_stmt                     shift and go to state 20
    if_stmt                        shift and go to state 21
    while_stmt                     shift and go to state 22

state 109

    (59) exp_tail -> COLON exp exp_tail .

    RPAREN          reduce using rule 59 (exp_tail -> COLON exp exp_tail .)


state 110

    (24) if_stmt -> IF LPAREN exp RPAREN LBRACE stmt_list . RBRACE else_part

    RBRACE          shift and go to state 112


state 111

    (27) while_stmt -> WHILE LPAREN exp RPAREN LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 113


state 112

    (24) if_stmt -> IF LPAREN exp RPAREN LBRACE stmt_list RBRACE . else_part
    (25) else_part -> . ELSE LBRACE stmt_list RBRACE
    (26) else_part -> . empty
    (53) empty -> .

    ELSE            shift and go to state 115
    ID              reduce using rule 53 (empty -> .)
    PRINT           reduce using rule 53 (empty -> .)
    INPUT           reduce using rule 53 (empty -> .)
    IF              reduce using rule 53 (empty -> .)
    WHILE           reduce using rule 53 (empty -> .)
    RBRACE          reduce using rule 53 (empty -> .)

    else_part                      shift and go to state 114
    empty                          shift and go to state 116

state 113

    (27) while_stmt -> WHILE LPAREN exp RPAREN LBRACE stmt_list RBRACE .

    ID              reduce using rule 27 (while_stmt -> WHILE LPAREN exp RPAREN LBRACE stmt_list RBRACE .)
    PRINT           reduce using rule 27 (while_stmt -> WHILE LPAREN exp RPAREN LBRACE stmt_list RBRACE .)
    INPUT           reduce using rule 27 (while_stmt -> WHILE LPAREN exp RPAREN LBRACE stmt_list RBRACE .)
    IF              reduce using rule 27 (while_stmt -> WHILE LPAREN exp RPAREN LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 27 (while_stmt -> WHILE LPAREN exp RPAREN LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 27 (while_stmt -> WHILE LPAREN exp RPAREN LBRACE stmt_list RBRACE .)


state 114

    (24) if_stmt -> IF LPAREN exp RPAREN LBRACE stmt_list RBRACE else_part .

    ID              reduce using rule 24 (if_stmt -> IF LPAREN exp RPAREN LBRACE stmt_list RBRACE else_part .)
    PRINT           reduce using rule 24 (if_stmt -> IF LPAREN exp RPAREN LBRACE stmt_list RBRACE else_part .)
    INPUT           reduce using rule 24 (if_stmt -> IF LPAREN exp RPAREN LBRACE stmt_list RBRACE else_part .)
    IF              reduce using rule 24 (if_stmt -> IF LPAREN exp RPAREN LBRACE stmt_list RBRACE else_part .)
    WHILE           reduce using rule 24 (if_stmt -> IF LPAREN exp RPAREN LBRACE stmt_list RBRACE else_part .)
    RBRACE          reduce using rule 24 (if_stmt -> IF LPAREN exp RPAREN LBRACE stmt_list RBRACE else_part .)


state 115

    (25) else_part -> ELSE . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 117


state 116

    (26) else_part -> empty .

    ID              reduce using rule 26 (else_part -> empty .)
    PRINT           reduce using rule 26 (else_part -> empty .)
    INPUT           reduce using rule 26 (else_part -> empty .)
    IF              reduce using rule 26 (else_part -> empty .)
    WHILE           reduce using rule 26 (else_part -> empty .)
    RBRACE          reduce using rule 26 (else_part -> empty .)


state 117

    (25) else_part -> ELSE LBRACE . stmt_list RBRACE
    (14) stmt_list -> . stmt stmt_list
    (15) stmt_list -> . empty
    (16) stmt -> . assign_stmt
    (17) stmt -> . print_stmt
    (18) stmt -> . input_stmt
    (19) stmt -> . if_stmt
    (20) stmt -> . while_stmt
    (53) empty -> .
    (21) assign_stmt -> . ID ASSIGN exp SEMICOLON
    (22) print_stmt -> . PRINT LPAREN exp_list RPAREN SEMICOLON
    (23) input_stmt -> . INPUT LPAREN id_list RPAREN SEMICOLON
    (24) if_stmt -> . IF LPAREN exp RPAREN LBRACE stmt_list RBRACE else_part
    (27) while_stmt -> . WHILE LPAREN exp RPAREN LBRACE stmt_list RBRACE

    RBRACE          reduce using rule 53 (empty -> .)
    ID              shift and go to state 14
    PRINT           shift and go to state 23
    INPUT           shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26

    stmt_list                      shift and go to state 118
    stmt                           shift and go to state 16
    empty                          shift and go to state 17
    assign_stmt                    shift and go to state 18
    print_stmt                     shift and go to state 19
    input_stmt                     shift and go to state 20
    if_stmt                        shift and go to state 21
    while_stmt                     shift and go to state 22

state 118

    (25) else_part -> ELSE LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 119


state 119

    (25) else_part -> ELSE LBRACE stmt_list RBRACE .

    ID              reduce using rule 25 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    PRINT           reduce using rule 25 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    INPUT           reduce using rule 25 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    IF              reduce using rule 25 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 25 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 25 (else_part -> ELSE LBRACE stmt_list RBRACE .)

